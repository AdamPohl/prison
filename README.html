<!doctype html public "-//W3C//DTD HTML 3.2 Final//EN">
<!-- --------------------------------------------------------------------- -->
<!-- $Id$ -->
<!-- Bruno BEAUFILS <beaufils@lifl.fr> -->
<!-- prison - Fichier d'explications -->
<!-- --------------------------------------------------------------------- -->

<html>

<head>
<title>README for prison</title>
</head>

<body>

<center>
<table border=1 align=center width="90%">
  <tr>
    <td align=center><font size=+4><strong>Iterated Prisoner's
    Dilemma</strong></font><br><hr>
            <table>
              <tr>
                <td valign=top><strong>Authors : </strong></td>
                <td>Philippe MATHIEU<br>Jean-Paul DELAHAYE<br>Bruno
                BEAUFILS</td> 
              </tr>
            </table>
            <hr>
            <a href="http://www.lifl.fr/IPD">PRISON</a>, Copyright &copy;
            1992-1998 by <a href="http://www.lifl.fr">LIFL</a> (<a
            href="http://www.lifl.fr/SMAC">SMAC</a> team)  
            <p>
          </td>
        </tr>
      </table></center>

<br>
<hr>
<center>    <strong> 
      This program is distributed in the hope that it will be useful,
      but WITHOUT ANY WARRANTY; without even the implied warranty of
      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
      Contact the authors for more details.

</strong>
    </center> 
<br>
    <center><table width="90%">
      <tr>
        <td align=center>
          Please contact us for any bug, any difficulty or any
          improvement idea.
          <br>
          Please take last version on <a
          href="http://www.lifl.fr/IPD">http://www.lifl.fr/IPD</a>
          <br>
          Please send us an e-mail if you use this software. With your address
          We will be able to tell you if there has been changes in the new
          version or to give new contributions (<a
          href="mailto:prison@lifl.fr">prison@lifl.fr</a>)</td> 
      </tr>
    </table></center>
<hr>

<h1>Introduction</h1>
Let two artificial agents have the choice between cooperation and
defection. They play one against the other, in a synchronous manner,
so that they do not know what the other will play. They get a score
according to the situation of the move:

    <ul>
      <li>They both cooperate and then get both the cooperation reward, let
        evaluate it to R points; 
        
      <li> They both defect and then get both the selfish punishment, let
        evaluate it to P points; 
        
      <li> One chooses to defect while the other chooses to cooperate, then
        the one who has defected gets the selfish temptation salary, let it be
        T points, and the one who has cooperated gets the sucker score, let it
        be S points.
    </ul>
    
<p>
    To have a dilemma, temptation must be better than cooperation, which must
be better than punishment, which must be better than to be the sucker. This
can be formalised as: T>R>P>S

<p>
Since this one-shot version of the Prisoner's Dilemma is not very interesting
(the most rational choice is to defect), the game is iterated, the final score
being the sum of all the moves scored. Each player does not know how many
moves there will be, thus each agent's strategy can be studied, to look, for
instance, how each player tries to put cooperation in the game.
<p>
To avoid the one-shot Prisoner's Dilemma solution to influence strategies, by
giving too much importance to temptation regarding cooperation, it is useful
to add the following restriction : 2R>T+S
<p>
With this restriction, strategies have no advantage in alternatively operate
and defect.
<p>
To study the behavior of strategies, two kinds of computation can be done.
<p>
The first one is a simple round-robin tournament, in which each strategy meets
all other strategies. Its final score is then the sum of all scores done in
each confrontation. At the end, the strategy's strength measurement is given
by its range in the tournament.
<p>
The second one is a simulated ecological evolution, in which at the beginning
there is a fixed population including the same quantity of each strategy. A
round-robin tournament is made and then the population of bad strategies is
decreased whereas good strategies obtain new elements. The simulation is
repeated until the population has been stabilised (the population does not
change anymore). This is this way that nasty strategies, those who take the
initiative of the first defection, have been discovered to be not very stable,
because they are invaded by kind ones.

<h1>Present version</h1>

    <p>This version allows you to simulate the Iterated Prisoner's Dilemma
with many options as well as other variants like Leader's Dilemma,
Lift Dilemma, renouncement Dilemma etc... in simple round robin
tournament or in ecological evolution. For each experiment you can
obtain many traces and a graphical representaton of population
evolution.
</p>
    <p>This program allows you to create your own strategies and make them
enter in competition with the choosen panel.
</p>
    <p>In this aim, this package contains more than 50 strategies to play the
game.
</p>
    <p>This program is able to give you in output not only graphical
representations of ecological evolutions but also a trace of each
confrontation made, a trace of the total score table after tournament
or a trace of ecological computation generations (1 every 10
generations).
</p>
    <p>You also obtain analysis of each round-robin tournament made,
with, for each strategy the best gap, worst gap, best score, worst 
score it obtained.
</p>
    <p>It is written in standard Ansi C to allow you to compile the program
code with your strategies on any system. Actually it has been tested
on many Unix systems, on DOS 6.x and Windows 3.x and 4.x
</p>
    <p>This program is initially configured to run with the 12 strategies
described in the article "L'altruisme perfectionne" published in "Pour
La Science" revue, vol 181, Nov 92 as well as with for the 21
strategies of the internal publication IT 233 of the LIFL (ftp.lifl.fr
in pub/reports/IT-publi)
</p>
    <p>The following points indicate the way to follow to run this program,
change strategies or add yours.
</p>
    <p>If you have any problem, you can send me an e-mail at mathieu@lifl.fr.
I will answer you, if i can, i soon as possible.
</p>

    <h1>Packages contents </h1>
    
    <ul>
      <li> In the <tt><strong>prison</strong></tt> directory
        <table>
          <tr><td><tt>changes         </tt></td><td>Traces of last modifications to the package</td></tr>
          <tr><td><tt>readme          </tt></td><td>The file you are already reading</td></tr>
          <tr><td><tt>prison.c        </tt></td><td>Source program for IPD simulator</td></tr>
          <tr><td><tt>tinypri.c       </tt></td><td>Source program for a light version of the IPD simulator</td></tr>
          <tr><td><tt>getopt.c        </tt></td><td>internal file under GNU licence</td></tr>
          <tr><td><tt>getopt.h        </tt></td><td>internal file under GNU licence</td></tr>
          <tr><td><tt>strategy.h      </tt></td><td>Strategies list used by the program</td></tr>
          <tr><td><tt>classics.str    </tt></td><td>Classical strategies used by default</td></tr>
          <tr><td><tt>renounce.str    </tt></td><td>Strategies code for renouncement</td></tr>
          <tr><td><tt>lift.str        </tt></td><td>Strategies code for lift dilemma</td></tr>
          <tr><td><tt>pls.str         </tt></td><td>Strategies code for the tournament made with PLS 187, Mai 93</td></tr>
          <tr><td><tt>misc.str        </tt></td><td>Several other strategies</td></tr>
          <tr><td><tt>slaves.str      </tt></td><td>A master-slaves model</td></tr>
          <tr><td><tt>translat.nam    </tt></td><td>correspondance between French and English strategy names</td></tr>
          <tr><td><tt>translat        </tt></td><td>script for Unix to translate from English to French</td></tr>
          <tr><td><tt>makefile        </tt></td><td>makefile to build all versions under Unix system</td></tr>
          <tr><td><tt>interface.c<br>mainwindow.c<br>setupwindow.c<br>tracewindow.c<br>xmain.c</tt></td>
            <td valign=top>Files used for the GUI of prison (xprison)</td>
          </tr>
          <tr><td><tt>sample1<br>sample2<br>sample3<br>sample4</tt></td><td valign=top> examples saved to run with xprison</td>
          </tr>
      </table>
      <li> In the <tt><strong>prison/dos</strong></tt> directory
        <table>
          <tr><td><tt>prison16.exe</tt></td><td> executable for DOS, Windows 3.1, Windows 95 and W/NT in 16 bits</td>
          </tr>
            <tr><td><tt>prison32.exe</tt></td><td>executable only for Windows 95 and Windows NT in 32 bits</td>
          </tr>
          <tr><td><tt>tinypri.exe </tt></td><td><em>light</em>version of the
          executable for DOS in 32 bits</td>
          </tr>
            <tr><td><tt>gnuplot.exe</tt></td><td>The gnuplot executable</td>
          </tr>
          
        </table>    </ul>

    <h1>Variants </h1>

    <p>You can run many IPD variants at the command line. For example these
are some possible games :
</p>
    <table>
<tr><td>Prisoner's dilemma              </td><td>:</td><td><tt>  prison</tt></td></tr>
<tr><td>Prisoner's dilemma with noise   </td><td>:</td><td><tt>  prison -N5  </tt>(for 5% noise)</td></tr>
<tr><td>Prisoner's dilemma with loss    </td><td>:</td><td><tt>  prison -L50 </tt>(for 50 loss at each generation)</td></tr>
<tr><td>Leader's dilemma                </td><td>:</td><td><tt>  prison -s3 -p0 -r1</tt></td></tr>
<tr><td>Lift dilemma                    </td><td>:</td><td><tt>  prison -t8</tt></td></tr>
</table>

    <h1>Compilation</h1>

    <p>This program has been entirely written in ANSI C. You just have to
compile the file prison.c to obtain a new runable program.
</p>
    <p>If you are under Unix, you have already access to a C compiler and to
the MAKE utility. You just have then to run
</p>
<pre>
    make prison
    or 
    make tinypri
    or 
    make xprison
</pre>
If you are under DOS and have Turbo C, you just have to run
    <pre>
    tc prison.c /b
    or
    tc tinypri.c /b
</pre>

Remember : runable versions already exist in the archive for 16 bits (Windows
    3.1 or DOS) as well as 32 bits (Windows 95 or NT) 

    <h1>Matrix Payoff</h1>

    <pre>
+----------------+---------------+---------------+---------------+
|                |               |               |               |
|                |  COOPERATE    |     DEFECT    |     RENOUNCE  |
|                |               |               |               |
|----------------+---------------+---------------+---------------|
|                |               |               |               |
|  COOPERATE     |   (R)eward    |    (S)ucker   |   N           |
|                |               |               |               |
|----------------+---------------+---------------+---------------|
|                |               |               |               |
|  DEFECT        | (T)emptation  |  (P)unishment |   N           |
|                |               |               |               |
|----------------+---------------+---------------+---------------|
|                |               |               |               |
|  RENOUNCE      |   N           |   N           |   N           |
|                |               |               |               |
+----------------+---------------+---------------+---------------+
</pre>

    <h1>How to run it</h1>

    <pre>prison          run the program with default options
</pre>

    <p>The program prints on the screen all the parameters used such as the
number of strategies that will be in tournament.
</p>
    <p>Many parameters can be changed on the command line:
</p>
    <pre>
prison -h       gives this help message

-r &lt;int&gt;    double cooperation value (R)eward           (default 3)
-p &lt;int&gt;    double defect value (P)unishment            (default 1)
-t &lt;int&gt;    defect against cooperate (T)emptation       (default 5)
-s &lt;int&gt;    cooperate against defect (S)ucker's score   (default 0)
-n &lt;int&gt;    Renouncement                                (default 2)
-l &lt;int&gt;    confrontation (l)ength                      (default 1000)
-R &lt;int&gt;    number of random strategies (R)epetition    (default 8)
-g &lt;int&gt;    number of (g)enerations computed            (default until stab.)
-S &lt;int&gt;    (S)eed value : 0 if real random game        (default 1)
-L &lt;int&gt;    (L)oss in each generation                   (default 0)
-N &lt;int&gt;    percentage (N)oise value                    (default 0)
-a &lt;string&gt; strategies subclass taken into (a)ccount    (default all)
            (y|n)* or list of strategy number separated by commas 
-o          (o)utput usable strategies list 
-h          this help message 
</pre>

    <p>The program have initially classical strategies in its memory. They are all
described in the classics.str file.
</p>

    <p>The -o option gives you the list of all the strategies you can run
with their respective number.
</p>
    <p>The -a option allows you to make any confrontation you want between a
subclass of these classical strategies.  You just have to pass an argument
composed of y (for yes) and n (for no) which means that strategies on
index corresponding to a 'y' in the string are choosen. You can also
specify the strategies you want by their number separated by commas.
If this option is not used (default) all the strategies are used.
</p>
    <p>The -L option allows to use a loss perturbation during the
computation.  At each generation loop, a few number of entities will
be destroyed randomly.  The number of destroyed entities must be
specified after the -L.
</p>
    <p>The -N option allows tou to play the game with noise. This option uses
a percentage which defines the noise probability.  For example -N5
will change the play in 5% times.
</p>

    <p>At each run, a file with .bat suffix is created to allow you to recall
the parameters used for this experiment.  If you are under DOS you
just have to run this bat file again to run the same experiment with
the same options.  If you are under Unix you will just have to change
its mode (chmod *.bat +x) to be able to run it.
</p>
    <p>If a graphical representation is asked, the plotter GNUPLOT will be
automatically runned to show the plot result. Be sure GNUPLOT can be
accessed in you PATH variable.
</p>

    <h1>Many other tournaments</h1>

    <p>To specify a subclass of strategies for confrontation you know that
you must use the -a option with (y|n)* string.  Of course if there are
33 strategies and you just want the first ones you dont have to build
a string of length 33. If string is less than 33 in length no other
strategies will no be used.
</p>
    <p>When you choose some strategies you must respect the order of the
'foreseen' array (which contains the subclass expected) in the file
'strategies'
</p>
    <p>prison -o    gives you this order on the screen

 1  gentille
 2  mechante
 3  lunatique
 4  tit_for_tat
 5  rancuniere
 6  per_mechante
 7  per_gentille
 8  majo_mou
 9  mefiant
10  majo_dur
11  sondeur
12  tft_dur
13  gradual
14  tf2t_hard
15  tf2t_kind
16  joss_dur
17  joss_mou
18  coop_puis_tc
19  hesitante
20  ccctct
21  c_4_sur_5
22  quatre_c_un_t
23  calculateur
24  sondeur2
25  sondeur3
26  sondeur4
27  sondeur_dur
28  mieux_en_mieux
29  pire_en_pire
30  pire_en_pire2
31  pire_en_pire3
32  doubleur
33  ranc_mou
34  pavlov
35  gradual_killer
36  slow_tft
</p>

    <h1>Some examples</h1>

    <dl>
<dt> to obtain the help message
<dd><tt>    prison -h</tt></dd>

<dt> to obtain the list of allowed strategies
<dd><tt>    prison -o</tt></dd>

<dt> classical IPD simulation between the classical strategies
<dd><tt>    prison</tt></dd>

<dt> classical simulation between gentille, mechante and lunatique
<dd><tt>    prison -a yyy</tt></dd>

<dt> classical simulation between gentille, tit_for_tat, per_mechante and sondeur 
<dd><tt>    prison -a 1,4,6,11</tt></dd>

<dt> simulation between mechante and gentille
<dd><tt>    prison -a yy</tt></dd>

<dt> simulation between mechante and tit_for_tat with a LOSS of 5 death in each loop
<dd><tt>    prison -a nyny -L5</tt></dd>

<dt> simulation between mechante, tit_for_tat and gentille with a real
random seed and a game length of 10 rounds
<dd><tt>    prison -a 1,2,4 -S 0 -l 10</tt></dd>

<dt> simulation between the 11th first deterministic strategies with a
score of 6 for DEFECT against COOPERATION
<dd><tt>    prison -t 6 -a yynyyyyyyyyy</tt></dd>

<dt> simulation between mechante, majo_dur, majo_mou, mefiant and graduel 
at the lift dilemma with seed fixed at 5
<dd><tt>    prison -t8 -a 2,8,9,10,13  -S5</tt></dd>

<dt> simulation between gentille lunatique and rancuniere at the lift
dilemma with a real random seed and a game length of 10 rounds
<dd><tt>    prison -a ynyny -t8 -S0 -l10</tt></dd>
</dl>

    <h1>Using the simulator</h1>

    <h2>Program Parameters </h2>

    <h3>game length and score computation</h3>

    <p>This program is arranged to run 1000 play games by default You can
change it with -l
</p>
Scores are computed in the following way (Classical IPD)

    <ul>
<li> double cooperation value: 3 points each
<li> double defect value: 1 point each
<li> renouncement : 2 points each
<li> defect against cooperate : resp. 5 et 0 points.
</ul>

You can change this with -r -p -t -n -s 

    <p>Each game with a random strategy is played 8 times to obtain a more
reliable behavior. You can change this with -S
</p>

For example, to play 
    <ul>
      <li> Lift dilemma         : <code>prison -t8</code>
      <li> Leader's dilemma     : <code>prison -r1 -s3 -p0</code>
      <li> IPD with noise   : <code>prison -N5</code>
      <li> IPD with loss        : <code>prison -L80</code>
</ul>


    <h3>random generator</h3>

    <p>If some of the strategies uses a random generator you will have many
difficulties to obtain the same result between two identical
experiments.
</p>
    <p>Initially the random generator seed is fixed to 1. By this way, all
your experiments can be reproduced exactly.
</p>
    <p>You can change the seed with the -S option.  If you use -S0 then a
real random generator will be used.
</p>
    <p>By the same way, each game with a random strategy is played 8
times. You can also change this with the -R option
</p>

    <h2>Messages signification</h2>

    <strong>Tournament, Generations, Subclass, Domination, Cycles (T/G/S/D/C) ? 
</strong>
    <p>
T) You run a round robin tournament between all the choosed
strategies.
</p>  
    <p>
G) Not only you run a round robin tournament but you also count scores
in population and you iterate this process until stabilization.
</p>
    <p>S) Subclass allows you to compute all the confrontations between all
the chosen strategies except 1 or 2.  With n choosen strategies it
will then run n confrontations if you choose the (n-1) option and
(n(n-1)/2) with the (n-2) option.
</p>
    <p>D) Domination allows you to know if between the chosen strategies one
of them wins against all the others in a two by two tournament.  You
can choose between weak or strong domination according to counting
score against itself or not.
</p>

    <p>C) Cycles allows you to know if between the chosen strategies you can
find loops of 3 winning strategies : A wins against B, B wins against
C and C wins against A in a 2 by 2 tournament.  You can choose between
weak or strong cycles according to counting score against itself or
not.
</p>

    <strong>Output files prefix name ?  </strong>

    <p>After each experiment the program is able to keep trace of many
results obtained in different files. All these generated files for an
experimentation will have the same prefix name.  This allows you to
find them easily if you make many experimentations.
</p>

    <strong>Trace of each confrontation                        (Y/N) ?   </strong>

    <p>You can have, for each game played, the 30 first plays by strategies
in each confrontation. The program prints also, for each game the
score obtained by each strategy. If this trace is asked it will be
written (in Ascii) in a .trace suffix file
</p>

    <strong>Trace of the total score table after tournament    (Y/N) ?  </strong>

    <p>You can obtain a trace of the cumulative score table after the round
robin tournament for each strategy. This output will be sorted by
decreasing order of the population quantity (The winner is at the
top).  If this trace is asked it will be written (in Ascii) in a
.trace suffix file
</p>

    <strong>Trace of ecological computation generations (1/10) (Y/N) ?  </strong>

    <p>You can obtain every 10 generations the intermediary state of the
entities population during ecological computation.  All these results
are sorted by decreasing order of the population quantity This can of
course be obtained only if you asked for Generation at the first
query.  If this trace is asked it will be written (in Ascii) in a
.trace suffix file
</p>


    <strong>Trace of score matrix                              (Y/N) ? </strong>
    <p>
If you want to obtain a matrix representation of the scores between
two strategies, you can have it with this option.  This matrix can be
easily loaded in your SpreadSheet for a pretty presentation.  If this
trace is asked it will be written (in Ascii) in a .trace suffix file
</p>

    <strong>If you asked for Subclass</strong>
<br>
    <strong>Tournament or Generations ?</strong>
    <p>     T or G for choosing between an autotest on tournaments 
        or an autotest on generations.
</p>
    <strong> Size of subclasses ? </strong>
    <p>     the size of the subclasses you want to compute.
        Be careful to what you asked for, it can take a long time !
</p>
<br>
    <strong>If you asked for Domination</strong>
<br>
    <strong>Strong or weak domination (1/2) : </strong>
    <p>     1 or 2 for choosing if in a round robin tournament a 
        strategy plays against itself.
</p>
<br>
<br>
    <strong>If you asked for Cycles</strong>
<br>
    <strong>Strong or weak cycle (1/2) : </strong>
    <p>     1 or 2 for choosing if in a round robin tournament a 
        strategy plays against itself.
</p>

    <strong>File for graphics output                           (Y/N) ?</strong>

    <p>This will create a text file which can be used by a plotter.  It
contains the complete not sorted trace of populations during time.
This file can easily be loaded in your SpreadSheet to obtain a good
graphical representation. It can also be used by GNUPLOT by simply
running 'gnuplot *.cmd' (* is the prefix name choosed before) at the
end of the computation.
</p>
    <p>If this trace is asked it will be written (in Ascii) in a .data suffix
file and the GNUPLOT commands in a .cmd suffix file. The file .cmd is
automatically created to plot only the 20th best first strategies of
the ecological evolution.
</p>
Be sure to have GNUPLOT access in your PATH for this option.




    <h2>Generated files </h2>

    <ul>
<li> .bat file generated which contains the command line used for this
experimentation

<li> .tra file generated which contains games trace, scores and
evolutions depending what you asked for.

<li> .dat file generated which contains data for a graphical
representation of population evolution

<li> .cmd file generated which contains GNUPLOT commands to obtain a
postscript file

<li> .ps file generated which contains the postscript graphic file of the
evolution.
</ul>

    <h1>Adding strategies</h1>
    <h2>Strategy creation</h2>

    <p>

You must write strategies in C language, but a rough knowledge of this
language is sufficient to write many kinds of strategies.
</p>
    <p>
Each strategy corresponds to a C function which has for input
parameter an int X and which has for output a card type which is
DEFECT, COOPERATE or RENOUNCE.
</p>
    <p>Each play of any player can be seen in history arrays. You can access
to MH[] (for my_history) and RH[] (for rival's history).  For example
MH[53] is my play at the 53rd play.
</p>
    <p>The number of the current play can be obtained with the 'turn'
variable.
</p>
    <p>Warning, players plays simultaneously thus it is not possible to
obtain the rival's play at the 'turn' play.
</p>
    <p>If you want to use static variables to write your strategy like
counters, you can do it but you must declare these variables with a
"static counter" type.  When you use it , you must always use it like
an array at the X index.  Of course X must not be changed.  See
"graduel" strategy for an example.
</p>

    <h2>Utilities</h2>
    <p>
Some utility functions have been written to help you to write your own
strategies :
</p> 
    <ul>
<li>nbC(MH), nbC(RH) returns the number of cooperations made by me or my
rivals since the beginning of the game.

<li>nbD(MH), nbD(RH) returns the number of defections made by me or my
rival since the beginning of the game.

<li>score(MH), score(RH) returns my current score or the current score of
my rival since the beginning of the game.

<li>score_lim(n,MH) , score_lim(n,RH) returns my score or the score of my
rival during the n last plays.

<li>defect_lim(n,MH), defect_lim(n,RH) returns my number of defections or
the defections of my rival during the n last plays.
</ul>


 Example : 
 I want to write a strategy which plays COOPERATE if the rival has
 COOPERATE at least as much as me, and which plays RENONCE if it has
 not obtained more than 10 points during the last 5 plays.
 It DEFECTs in the other cases.

    <pre>
 card essai(int X)
 {
      if (nbC(RH)&gt;=nbC(MH) return COOPERATE;
      if (turn>5 && score_lim(5,MH)&lt;10) return RENOUNCE;
      return DEFECT;
 }
</pre>

    <h2>How to add a new strategy</h2>

    <p>After having written your own strategy, how can you add your strategy
to the current panel ?
</p>
    <p>In fact you just have to edit the file 'strategies' with your usual
editor. You can of course use a variant of one of the strategies which
you will find in str* files.
</p>

    <ol>
<li>At the beginning of 'strategies' you write your strategy in the
correct format (see below) Be sure that there is no other strategy
with the same name.


<li>Then you must declare this new strategy in the array just at the
end.

Each record must be in this format:
        <pre>
  "extern_name",internal_name,100,0,X,0,
</pre>
        <ul>
  <li>extern_name is the name that you want to see in the results and
     graphics.
  <li>internal_name is the name of the procedure coding your strategy
  <li>The third parameter is the size of initial population for
     ecological evolutions. Usually we put 100 for all of them.
  <li>0 is required as 4th argument
  <li>X must be replaced by 0 or 1. 0 if your strategy does not make
     use of random
     and 1 if there is any rand() in it.
  <li>0 is required at last argument
</ul>
For example if you want to see invasion phenomena like 100 tit_for_tat
invading 900 m‰chantes, you must initialize the strategy array with
these 2 lines.
        <pre>   
    "tit_for_tat",tit_for_tat,100,0,0,0,
    "mechante",mechante,900,0,0,0,
</pre>

<li>save the 'strategy.h' file

<li>recompile prison.c with your C compiler
</ol>

    <blockquote><strong>Warning</strong>: This program is configured to use 50 strategies maximum.
This is defined in the constant NB_STRAT_MAX at the beginning of
prison.c If you want to use more than 50 strategies, change this
constant.  Under DOS you will perhaps have to compile with Compact or
Large model if your code is too important.
</blockquote>

    <h1>Warning</h1>

    <p>   If you change anything in this program, be sure to avoid an                
   overflow error in arithmetic computations                                  
</p>                                                                              
    <p>   Sensitive variables are score_matrix, sum, ent_for_one and total           
   Which are used in generations_loop                                         
</p>                                                                              
 max values :                                                                 
    <ul>
<li> score_matrix: GAME_LENGTH * max_pts                                                       
<li> cumul:       NB_STRATEGIES * GAME_LENGTH * max_pts                                        
<li> ent_for_one: NB_STRATEGIES * pop_init * GAME_LENGTH * max_pts                             
<li> total:       NB_STRATEGIES * NB_STRATEGIES * pop_init * pop_init * GAME_LENGTH * max_pts  
</ul>                                                                                           


  <br>

  <hr> 

  <center>
    <address>
      Copyright &copy; 1992-1998 by
      <a href="http://www.lifl.fr/">LIFL</a>
      <a href="mailto:prison@lifl.fr">&lt;prison@lifl.fr&gt;</a><br>
<!-- hhmts start -->
Last modified: 1998/11/20 - 2:8 
<!-- hhmts end -->
    </address>
  </center>


</body>
</html>
